---
title: 42 - Using Automated Tests to Help Teach Python - Trey Hunner
date: Wed, 27 Jun 2018 21:00:00 -0700
url: /testandcode/42-automated-tests-help-teach-python
---

This interview with Trey Hunner discusses his use of automated tests to help teach programming.

<iframe src="https://fireside.fm/player/v2/DOAjrBV2+Q3TrILzu" width="740" height="200" frameborder="0" scrolling="no">
</iframe>

---
Transcript for [episode 42](https://testandcode.com/42)
of the [Test & Code Podcast](https://testandcode.com/)

<em>This transcript starts as an auto generated transcript.</em><br/>
<em>[PRs welcome](https://github.com/okken/testandcode_transcripts) if you want to help fix any errors.</em><br/>

<!-- 
For people reading this on GitHub, the final page will be displayed at https://pythontest.com/testandcode
-->

---

Hello and welcome to Test and Code, a podcast about software development, software testing and Python.

Automated software testing is a huge part of developing great software, but some new developers don't get exposed to automated tests until quite some time into their learning of programming, but that is changing. New ways to teach programming include automated tests from the beginning. One of the people doing this is Trey Hunter. Trey Hunter is a Python and Django team trainer. He's also one of the directors of the Psf, and he's been using automated tests to help people learn Python. We'll talk to Tray about this and more. But first, this episode of Test and Code is brought to you by Talk Python to Me and Python Bytes podcasts. If you love Python podcasts in Python and you're listening to mine, so you must don't miss out on top Python. To me, it's the longest running and most well known of the Python podcasts and includes guests such as Guido Van Rossum, Luciano Romano, and even me. Go deep into the human side of Python, things you love over at Talkpython. Fm.

And if you're in a hurry and just want the headlines, don't miss out on the quick, Rapid fire Python Bites podcast that I cohost with Michael Kennedy over at Pythonbytes. Fm.

Get the backstory and the latest news with Doc Python and Python Bytes. Subscribe in your podcast client today by searching for Python.

Now let's talk to Trey.

I first met you at a Python meet up in Portland, and it's still the only no, I went one more time. So I've been to two Python meetups so far.

Nice.

Was that the first one? Yeah, I think that was the first one you're at because you told me, I don't really go to these. And I don't know if you assumed I was a regular or what, even though I didn't live in your city.

Yeah. And actually, the turnout, it was kind of nice because it was pretty small that day because there was some conference going on or something. But anyway, you do a lot of stuff. So instead of me trying to introduce you, I thought you could introduce yourself to how you like to be known.

Yeah.

The way that I talk about myself, as I say, I help Django teams with onboarding and team training, and I do Python training and teaching. I'm kind of transitioning a little bit into trying to teach folks individually because most of the work I do, I've done consulting for years, and my work tends to be focused on businesses.

But that work of working with individuals is something that I've never really been paid for. So that's something I'm eventually going to try to get into because it's so nice to be able to work with someone as an individual teaching them. As much as I like going into companies and working with their folks, it's just nice to be able to work with individuals impossible. But that's the way I think of myself currently, the last few years as I teach people Python and Django.

Okay, so you've been using how did you get into Python?

Why Python and why Jenko?

Yeah, good question.

A friend asked me when I was in College. Actually, he knew I did web stuff. I did web stuff my own for years. He asked if I could help him with his start up over winter break, make a website the back end for website. It was going to be in Python.

I said I'd never done Python before, but I figured I could pick it up because I did it for a week in school for fun. And it seemed like a pretty easy program that we should pick up if you need some other languages. And so I worked with him on that, and then I just kind of kept working with them. And then I got into another Python project, or rather, I found a client because I started doing freelance work and I chose Python and Django as a stack. I kind of had control over that option, and I've kept choosing it because when working in the web world, it was always my favorite thing to work with there. And in general, as a programming language, Python is just a joy of a language to work with.

Okay.

And Django is still working for you for whatever you need to do?

Usually, yeah, I would say so. I mean, one of the great things about it is if I'm trying to make a quick and dirty site or a site that's supposed to last either way, I mostly do the same switches and toggles that I'm picking there because it comes with authentication built in. It comes with these things that I can customize later. I usually just leave them at the default until months down the line, though.

Okay, that's interesting. Okay, well, one of the things that we wanted to talk about today is since you do a lot of training.

You'd mentioned to me that you include testing as part of the training and the learning process. And I thought it's something that's growing, actually. I think because we'll talk about some of the others later.

Did you always include testing in your training?

I didn't. So when I started doing training a few years ago, I did not have tests. I had a curriculum that was built around a Sphinx website. I had a lot of exercises. I knew from the beginning I wanted to be as exercise heavy as possible because you learned by doing. And I've kind of come from a background of having volunteer workshops that I was helping run in San Diego.

And the curriculum we used was always very hands on. So I know I wanted the hands on aspect. I hadn't thought about having each of the exercises have automated tests. So probably a year later, I just thought, I'm going to add tests for my exercises. I tried out adding tests for exercises for tutorial at Python. It worked out really well.

I added them for all the exercises in my curriculum. I had about 100 exercises at the time, I think, and it was amazing. It was probably the biggest change I've made to my own curriculum was adding those tests. And it's interesting because I didn't and still don't in my main intro curriculum teach testing or test driven development. But this adding of tests to the exercises themselves gets people exposure to the process, which is a really eye opening thing for them as well. But the biggest thing is it gives them feedback without me having to give them feedback individually. I don't have to necessarily go to each person in the room and tell them whether their code is correct. They know it's correct. They just don't know if it's readable, if it's fast, or those types of things. The test may not actually test.

Yeah, you said you include a lot of tests. How do you deliver those?

I've never been to one of your classes.

Right, great question. So I have a zip file that they download from our kind of class website, and they actually get a local copy of the class website. Afterwards, they have to download a. Zip file, and then they actually have to, depending on the class Pip install or requirements file to get that zip file kind of working. And then they can run a little homegrown test runner and the test runner is ugly, and it's code that is doing magical things that shouldn't be done in an actual test framework. But it makes things a little bit easier for them. They don't have to know about unit Test or Pi test or the dot notation for running specific tests. They just type in the exercise name and test. Pyxercise name and it figures out what it's supposed to do.

Okay, what do they type in?

They type in Python test. Py and the actual name of the exercise. They don't type in the test name, they type in the function name. For example, maybe get hypotenuse. If they're writing a function that takes into numbers, gets the hypotenuse of the A and the B. Okay. And then it finds where the tests are for that based on some I used to do a giant dictionary. Then I got lazy and did a Doc string lookup for a string search, which is not the way you should write your actual code. It's very brittle, but it hasn't broken down in the last few years. And while it makes it not easy to understand my test framework, which is a downside, it does make it so that it runs very easily for them.

The user interface for it is command line, but it's easy to do.

Exactly. Yeah, the user interface is still command line, but it's easier than if they were actually learning to run unit test or Pi test, where you've got to type out the name of the test because it's kind of a big step to say I want to run my tests versus I want to run my code.

There's a bit of confusion that it adds to them there occasionally. And I do explain that I've got a homegrown test runner. You type in the exercise name. This is not the way people usually do testing. The tests that I've written are usual. The test framework itself is not typical, and that's just kind of a little prerequisite I have to do with the explanation. I think it is worth it at this point, though. I may change that process, but that's not the important part. The important part of my mind is the tests themselves and the testing process. The fact that they are testing their code in an automated fashion as they work through these exercises.

Right.

It's a feedback for being able to just like, for instance, if an exercise has what do you say? Like maybe ten tests that go along with it or something, they can get farther along. So their initial implementation, maybe it passes one or two of the tests and then they can look at why the other ones are failing and try to make it better that way. Do you see people doing that?

I do. And the reason for that partly is I'm encouraging them to do so well, inadvertently, is the way I would think about it initially. But now on purpose. And this is something that a lot of folks who are teaching Python may not really think about consciously, is the fact that in your exercise for tests, you often have when you're describing the problem, a few test cases inputs and outputs, you're showing it a command line, for example. Those are usually the easy cases. Those are the cases that are not edge cases in the test themselves. I often have some more advanced tests that test things that functionality they may not have thought of, and it's just kind of assumed by the problem statement and they might overlook it. And I don't want to show that in the problem statement because it's just really distracting the first couple of minutes that you're working on it.

Yeah, I think it's an interesting idea, and I think it's one of the things I'd like to see more of, and we are seeing more of. So for instance, I'll highlight a couple of other places, like there's a website called check. Io that teaches coding through little exercises also. And it does a similar sort of thing that you tell whether or not your code works by running unit tests on it.

And then the guys at Pi Bytes are doing these pie bite challenges and they're doing the same thing they've got. I think they use Pi test actually in their stuff. But similarly, it's sort of the idea of learning how to define when you're done.

But I do like that I like the idea of having multiple tests so that you can it's not just right or wrong.

It's almost there, like most of the stuff or something.

Yeah.

Well, and it's interesting because check I. O. And the bytes of code thing, that the Pi bytes folks have those run in your browser, which is really convenient when you're doing this as an individual.

Maybe you don't have Python even installed on your machine. You can run it straight from the browser. In fact, you can even on your phone if you want. In my classes, though, they've got Python installed on the machines. We're working in a real programming environment there. So we have a local test, which is sort of another level. There's a site called exorcism. Io that actually does it that way where you've got to download the tests, run it on your computer. And I feel like that step there is even another level of feedback because the command line output is something you own. It's not something that is meant to be scary or weird. You're supposed to be able to understand it because it's a program you're running on your own computer.

Yeah, I forgot about exorcism, but that's a good point that you part of running Python or Python is you've got to be able to get it working on your computer and getting something to get used to some of the tests.

Actually, I'd like to see this sort of training make it back into the schools, because when I think I was pretty far into College before we started talking about testing, actually, and I think it was just sort of you try out your stuff and see if it works.

I guess I'll bring it that back before testing. Do people just doing manual tests then and trying it and see if it works in my classes?

Yeah, that was what people were doing, and that's what I was encouraging them to do. And they would write their code, check a case to see if it works. They sometimes wouldn't even check the other cases I had on the website because people are naturally lazy and they're not going to want to check every single case if I show them five or six cases because they may not know how to copy paste from the website to their terminal. Even if they do, maybe they don't want to copy paste individual lines. And so if they miss things when I then worked through the problem with them as a room, they would go, oh, I've been selling myself short. I didn't realize I actually implemented it the wrong way because they didn't have these tests to give them that feedback there.

Yeah, I think that using it as feedback. And while people are learning and stuff, so have you had feedback from people that have learned from you? Do they like this style of learning, or has anybody talked about it?

Yeah, I have. And that's actually I get different people saying different things with their favorite usually people will tell me something in the ballpark of the exercises are my favorite part of my class. They were telling me that before I had tests, though.

Now that there's the test there, I actually get some feedback that people look at my tests and say, we've been trying to write tests for our team or we are writing tests and there's some things I didn't know how to do. I've been looking at your test as a model of a good testing style, which makes me think I need to be careful about making actually really good tests when I write these things, because they may be copying what I do in terms of the style I use there. But yeah, I have had some really positive feedback about this process.

Some folks have actually said that when they were doing it without test the first couple of days because I said it's optional to install the test framework to get that working if you can't, for some reason.

And they didn't. And they were struggling to get things done in time because when they would work through an exercise, they're manually testing it. It's broken. They have to go back to their code. The bad thing is in Python, if you're in a Python shell, you re import a module. It doesn't re import it, keeps it cached.

And because it keeps it cached, if you re import it, you try to run it again, you've got a problem, you either have to go manually Reloaded or exit your shell, reenter it, set up your variables again, re import the code, and then run it a second time. That's a lot slower than just running your automated tests again.

Yeah. And the automated test will really impart everything.

Exactly.

You mentioned people learning faster with it or getting their work done faster. Part of it is because they don't have to keep trying to manually test all the different test cases. Right, right. That's still something we struggle with, actually, as an entire industry, I think, is trying to get people to realize that testing can make your development faster.

Absolutely. Yeah. It makes both the exercise part faster because really I've done the hard work for them of writing the tests. Most people would agree that in test drive development, the hardest part is the writing of the test initially, because it's just the thing that we're not used to. The very fast part. The part that is always faster is when you're running those tests against your code, you're getting that immediate feedback. I would actually argue, though, I had thought of it being faster as the initial reason I made these. I would say now, though, that it's actually made my exercises more clear. And that's actually a really big win, I think, as well.

When you're giving exercises, are you giving like a written statement of what the exercise is? Also, I do.

And that's the thing that they read, they hopefully understand if they don't understand or if the tests don't line up with that because they say, hey, I ran my test, they did something different than what I thought I was supposed to write. I've got a bug in my exercise or a bug in my tests, or both. And so this is really encouraging me to have an exercise that has clear inputs and clear outputs, because good exercises should have clear inputs and clear outputs. If I can't write a good test for my exercise, it's probably not a good exercise. It's vague or unclear.

But it's also giving them another takeaway. Not just a testing style, but one of the things they can take away from this is a lot of examples of this is a description of a problem and how to translate that description into a set of tests.

Absolutely. Yeah. Because actually they can see I've often done this a lazy way where my first couple of examples, I copy paste, I use them, and I change it from a shell output to an assert statement. And voila, I've made a test. I have the inputs, I have the outputs. Instead of being a little copy pasted shell example, it's now an assert shoved into one of my various tests there. And that's something they can see that very basic tests simply involve copy pasting the things you're already manually testing.

Yes. And also an example of doing tests small. So a test is testing one aspect of the solution, not one giant test that tests everything.

Yeah. And I'll often start the way I usually write them is that the first ones are the small ones. The first ones are it's going to fail for an empty list input, or it succeeds for that, maybe it does a certain thing, then one element, two elements, and then I'll sometimes combine a couple of them. Because one thing I do want to make sure that I'm kind of combining the idea of not unit test and integration tests, but smaller tests and bigger tests, and that if I've got a somewhat complex series of inputs, I want to test maybe a couple of cases at once just to make sure that they don't both work independently and not work together. But those are usually rare. Most of my tests are the more individual unity type of assertion that I'm making there. And they can see that there's very few of the bigger tests in there.

Yeah. But it's kind of good that you do some of the big tests as well, because if a test is checking regardless of your philosophy about that, there are good reasons why a lot of people think that a test should focus on one aspect and test that. However, not all tests do, and tests written by other people aren't always going to be like that. So being able to look at the output of the test and look at why it failed to make sure that you're understanding the assertion error, because I was actually going through an example that we'll talk about later. But similar to our problem, an exercise has a test that checks two different things and it failed. And I didn't know why. I couldn't tell just by the failure that there was something wrong.

I'm being vague, so I'll be more specific. You had one test that had not only does the input and output, is that correct, but if you pass in something wrong, does it assert in the correct way?

Oh, interesting.

And having that combined in one test confused me at first. I'm like, I'm doing this right. Oh, I didn't check for incorrect input.

Yeah. Well, and that's something that I've actually struggled with, that this is an interesting I don't know what I'd call it, but basically an interesting scenario of having people who are running tests who are the least familiar with tests and testing of anyone who I'm going to have run test in any of my code at all because they are doing it for the sake of learning something new. And so they're not familiar yet with the process of testing oftentimes, or especially with Python itself. And so when they see something like assert equal, and we'll talk about why this is a Cert equal input output or output input, they see that that line fails and it tells them the two things are wrong, they don't know what the input is. And so I often will try to avoid using a variable for the inputs and outputs that isn't very close to that assertion because I want it to be shown automatically in the trace back there, which is something that they're not going to notice to go dig in the code necessarily. I don't want them to have to go pop open the test file.

They really need to to understand it. And so it's kind of changed the way I write my tests as well to appease this particular audience oftentimes.

So there is an elephant in the room. The elephant is I know you use unit test and not pipe test.

I don't have a lot against unit test.

I just really love Pyth better.

Yeah.

So tell me why unit test and why not something else.

So I have thought about rewriting my test from unit test to pytest because they're in a class based model, which actually isn't the worst because I've got multiple classes in a module. I might actually keep with that even if I was doing Pi test. The bigger thing, though, is self dot assert equal, self assert greater than all these types of methods. They really give my students the wrong impression potentially that Python is a language that loves its classes, and then it loves Camel case as well. And then it loves this kind of X unit style sort of Java world of object oriented programming in the sense of writing tests and that isn't necessarily the case. So pytest the actual tests themselves I find easier to read. The reason I started with Unit test and code reason I've continued to use it is my test originally didn't require any Pip install in my intro class.

I don't actually require for any of my curriculum a Pip install. Typically, depending on what it is we're teaching or doing, usually we're focusing on Python fundamentals, which means standard library. Once I require a Pip install, they often need some kind of extra access root access on the server that they're on. If they're on a Linux machine, administrative access on the Windows machine they're on, they need to right click and open the command prompt in a different setting to get that.

They often can't just type Pip. Sometimes they need to type Python Three, M, Pip, that type of thing. On different machines, you have slightly different scenarios if you're on Python Two, which a lot of the companies I teach are still learning. In Python Two, I'm teaching them in Python Two even though they know they have to switch.

It's even harder then, because Pip isn't bundled with Python Two, unless you're on a newer version of 2.7, which unfortunately is not always the case for some of the servers they're on. So not having to Pip install is a really big motivator there. I actually do require them to make a virtual environment and Pip install for a lot of my classes at this point, though. So the only thing holding me back now is the sharing of tests and exercises between courses. I have workshops, I have classes, and I'll often reuse similar or the same exercises between these entities because I'll either expand the exercise or just literally copy paste it. Because if we're learning about comprehensions list comprehensions in a workshop, there's no reason I can't do the same exercise. This is when I teach that in a class setting. So I use unit tests for simplicity, not for the student's sake. Well, it is for the student's sake, but it's for the student's sake, not in the sake of reading the code, but for the sake of that set up. Because that set up time is really precious. When we're on site together, we only have so many hours together.

Reasonable. Although all of those we can work around.

Yes, well, many of those you can work around. You're right. All of them you can work around. But it does take more work on my part, and sometimes some extra very deep thinking about how to deal with the particular set up at a particular company.

Fair enough. For instance, I'm just going to get a touch on one. One of the things that I use at my company is we have a fairly annoying firewall.

So it isn't just even if you can install Python, it isn't just a matter of Pip install from somewhere else, because that requires proxy settings to get that to work, however.

So instead of having anybody deal with proxy settings, everything that we use for a particular set of tests, we have other dependencies as well, not just Pi test.

We can put those in a shared directory somewhere and point of requirements file at that. And so nobody has to even have an outside of the company connection to get all that to work. But anyway. Right.

So what you're saying is you can kind of take the. pytest installation. Zip file and have them run the whole setup. Pylocally to get that set up?

No, we just use Pip install.

Oh, right, yeah, right. If you have Pip Pip installed as it file locally.

Yeah, we're up to Python 36. So we can assume that you're lucky, but you're having to do something even with virtual environments. So virtual environment doesn't come free in 27, does it?

No, it does not. So the only reason I'm using virtual environments is because I'm using Pip. And if I'm using Pip, I don't want them to have to Pip install as an administrator because that creates a lot of potential headache. That might not even be possible.

And so we're using virtual environments. But you're right. Virtual environments do not come with Python Two at all. You actually have to Pip install them. If you don't have Pip, you've got a situation. So the problem with Pip installing them is you then need administrator access just for that.

However, usually if you have a newer version of Python Two and you're on Pic, the administrators of that box typically have been kind enough to have some kind of virtual environment floating around in your path there. So that's actually rarely been a problem. The usual problem has been you're on an old enough version of Python that we don't even have a Pip. We have to make a virtual environment to even get access to that Pip, or we might be stuck on easy install or something weird.

Okay, well, hopefully that will go away soon.

Yes, I hope so. Python Three will fix all of this. And I always love working with clients who have Python Three because it makes my life so much easier.

Definitely.

So you do the in person training or the training for businesses. Do you travel for that or is it mostly in the San Diego area?

I do. So I do have clients who are local or semi local. I do also do remote training, but usually remote training is followed up by onsite training.

So I do a mix of both. So I've traveled so far only across the US.

I'm open to other travel, although sometimes international travel can add complications in terms of income and that type of stuff. But yeah, I do travel for that.

Okay, then you're adding some type of in person one on one training. Now also, is that what you said?

Yeah. So it's not one on one training.

You mean working with individuals that I mentioned earlier. Yeah. So what I'm doing now is I'm adding this thing called Python Morsels that I started a few months ago. And well, actually, I started it before that. I guess I sort of soft launched it a few months ago to the folks who are on my mailing list. And I've essentially taken those exercises that I mentioned that I use for my courses that I've got over 100 of at this point. And I'm taking the ones out that are my favorites. Not my favorites because they're just my favorite exercise I wrote, but because they're the ones that in the class together. I usually like to do first in an exercise section because it really encourages thinking in a Pythonic fashion, that we're encouraging our brains to think about the tools that exist in Python but not in, say, another programming language we already knew, because a lot of the folks I'm teaching have some kind of programming background and their mind is not tainted by that background but has the baggage of that other language. Because when you're moving between languages, you want to do things in a way that's idiomatic in that new world. So I'm taking those exercises and releasing them one every week with tests with the exercise description. The problem statement goes out Monday. The solutions got Wednesday.

Two individuals, and I'm charging for that, but there is a free version of that as well there. And so I'm kind of taking the thing that I do in the corporate world for businesses, and I'm releasing that to individuals. And there are actually some folks who are in teams who have their whole team signed up, which is kind of exciting because that means that I'm delivering value to a company that wouldn't pay for me to come on site, probably, but want some kind of ongoing learning for their own team. There.

That's great. Yesterday I said, hey, Drake, can you send me a few of these? Yeah. And you did. And I read through them.

And one of them I read through completely without doing the exercise. And then one of them I tried I honestly tried to do it as is, but I had to convert all the tests to pytest first before I could figure it out. Man.

I woke up this morning to an email from Brian that said, your tests are broken. I fixed them and I clicked on the file and I stared at it for a little bit and I'm thinking, what's different about this? It looks a little different. Oh, this is using Pi test.

That's funny, because I really thought about this seriously when I was starting Python Morsels. And then I thought maybe this is the opportunity for me to convert my test from unit test to Pi test. I didn't yet, at least because I still have not had an exercise where I require a Pip install. We are on Python three.

However, at the point where I have even just a Pip install.

It either requires explaining what a virtual environment is, which can be a little bit of a mess if someone doesn't know about them. They should. But it's a difficult thing to explain or explaining how to install something with administrator access if you're not doing a virtual environment there. And neither of those things are an easy startup cost. Whereas right now the only thing that I require is you have Python three installed. You can get access to running Python and then the test file somehow within your IDE or whatever it might be, because a lot of folks who they've installed Python, they often install PyCharm. They don't necessarily know how to Pivot and get a virtual environment set up. And that's something that I don't want to require them to do on day one or week one there with my exercises.

That's completely reasonable. But you could send both.

You're right. I could actually. And that's honestly something that maybe I should consider doing in the future is taking all my tests, sending them the Unit test, or even what I could do is I'll send them the Unit test away and say if you want to run this with a little bit different output, you can run it through pytest. pytest will run those just fine. Even though my test might look a little ugly for you to read, you can still get the same output at least. So that's even something I could do there before I rewrite the test. Yeah.

And actually, that's one of the things I did initially. I ran your Unit test through pytest because I like the default that pytest runs them in the order they appear in the file.

Yeah, and that helps a little bit. But anyway, the Unit test is very capable as well. It's just like the things that you brought up, like the insistent on Camel case, and that you have to have it in a class.

It's a little jarring after looking at Python code to have to look at that sort of stuff.

But anyway, I'm not going to hurry you too much about that, but if you ever need any help converting some of your test exercises to Python, I'd be willing to help out with that.

Well, let you know. I've heard you know the person who wrote the book on it.

Yeah, I know that guy.

I want to talk about Marshalls a little bit. If people want to get these weekly things, we may as well plug it right now. What's the URL again?

So for the free ones, it's try Pythonmorcels.com. Try Pythonmorcels.com. For the paid ones, it's just Pythonmorcels.com. So this is something I've actually had that try URL up for a little while, but I kind of just experimented with it while I was at Pi, Tennessee, this year, kind of telling folks about it just to see what they thought of the free exercises and whether it interested people enough to end up paying for the ones that actually cost money.

You don't have to pay for the ones that cost money, you don't have to put in a credit card. And that's if you want just the four ones that are free, feel free to do them and call it a day and go do all the other various websites. There are a lot of other places on the Internet to work through exercises.

I wanted mine as a kind of more curated, very explanatory fashion.

And so there are those free ones folks can just sign up and get for free.

So I want to give you my reaction in real time. I haven't told you this ahead of time of my experience with these so far. I encourage people to do it. I heard about these a couple of months ago, and I figured I already know a lot about Python. I don't need the extra stuff. However, you've obviously spent a lot of time making these very, like you said, very curated. There's a few things about this. So what you end up getting is you get the original problem description. You've had to edit these and Whittle on them so that they're fairly concise but clear. And then you get the test file. And being the kind of the test head I am, I usually read the test file first and then read the problem description, and then we go back and read the test and then try it out. Now one of the things that was unexpected and awesome is two things, I guess. First is that you do have that there is those examples of how to translate a problem description to tests. And this is something that really we need to do more of in school and in colleges and even in high school is how to convert requirements. A problem description is another word for requirements. It is how to convert that to code and to test code. And should it be one giant test? Should it be a bunch of tests? How do you do that?

We just assume that's easy. It's not easy.

So those are some examples of that. But then I like that couple of ones that I've read so far. You started with, well, this is the obvious way to do it.

This is the obvious way to do the problem statement.

Do you mean in the solution email?

Yeah, in the solution email. It's like, here's one of these things, but we know it doesn't solve it solves a couple of the tests, a couple of requirements, but it doesn't solve others. And then you also give bonus requirements. So the things that are a little bit more advanced, so people that are like, maybe the original problem statement was so easy, but there's some like twists the language that you need to know to understand the rest of them.

And man, two problems in and you stumped me. But like, for instance, one of the ones was a daytime thing. So you're comparing dates and you deviously told people you've got dates that come in as a string, two dates, and then you have to return the one that's like, I guess, the earlier one or something. But you said it isn't normal date times. You're allowing things like March 65.

Yes.

Just to say don't use daytime if, you know daytime good for you, but that's not going to work for these tests.

Yeah.

And that was fun. But you did also show if you're really doing this in code, how to do that with daytime, you'd show that in the solution. But the thing I'm beating around the Bush, but you explored the problem space with the solution. You're not just giving one solution, you're giving multiple solutions. And the trade offs and talking about like this was, I guess, a different exercise nested if statement.

That's doable. But yeah, that was the exercise. A bunch of if statements. You can do that. But it's confusing and it's not really that readable and showing the different trade offs. And that's also part of learning to code is learning to be able to write a solution even if it's ugly and then look at it and go, I don't want to have to maintain that and to refine it. Maybe it's cleaner. And if you're in a hurry, great. Maybe that's one of those places where you stick a to do statement to say this is ugly.

These need comments, but I just really like that, and I think you're doing a good job with that.

Thank you. Yeah, the Fox can't see me, but I'm kind of beaming now a little bit. I'm very happy to hear this because that's the way that I was going into it. And what I was hoping people would take from it is you can be an advanced Python developer. In fact, there's someone who I know who's a core developer of a very large Django project or well, actually of Jengo itself, who's been working through these and told me these exercises have actually learned at least something from every email in terms of perspective or something I didn't think of, even if I knew how to solve it that way. It just didn't occur to me at the moment, because there's that initial moment of even if you're a beginning programmer, you get the, I guess, the confidence boost of I got the test to pass, which is an achievement in itself. And then there's the next level of did I write this in a way that is maybe the most idiomatic or more idiomatic or in a fashion that I would like as far as optimal readability with my code. And so walking through the various ways to solve it, it's really dissecting the problem, hopefully not until you've killed it, but until you've studied it enough that you could really wrap your mind around why you might solve it in different ways. And it makes me so happy to hear that because these exercises I've spent a long time on these in my courses, and this is something we do in class together when I'm on the site with the company, as we walk through various solutions, and I don't usually do it myself. This is something where I'll ask the room, we're doing mob programming, how would you solve this? Someone shouts out an answer. I asked them to walk me through it, and they usually get a little flustered because I'm putting someone on the spot to tell me what to type. Someone else steps in and says, no, I did it this way. And then we've got a dozen different ways to solve the same problem, and we kind of discuss which way is the best way. And that's what I'm trying to do in an email format. And so it's really exciting to me to write these because afterwards I have the feeling of accomplishment, and I've kind of explored this problem space in a way that feels fun to me as someone who's gone through this problem. So I hope actually folks who are working through the exercises and I actually need to talk to more folks about this. I hope people are doing the same thing. You don't just solve it one way. You think about maybe a couple of different ways to solve it.

Yeah. Well, I mean, like, for instance, a couple of settings that people are used to if they've gone through school or they've actually done a job interview is you've got one shot, right?

What's the answer? How do you solve this problem in a test or something or on a whiteboard in a job interview?

And actually, that's one of the things this wasn't going to be part about job interviews, but I interview people as well. And if you don't know this already, don't try to solve it in the most elegant, obvious, awesome way right away. One of the things one of the reasons why coding examples are on whiteboards and stuff happen in interviews is to talk about the problem and to write the obvious way down. And they go, well, this might work doing this, and then step back and say, some of this is a little bit ugly, and I haven't solved this part of it and do iterative programming on the whiteboard if you need to, right? Yeah.

It's a learned skill, also, of being able to come back and erase some of your code and try it again and explore the problem space if you have time.

It absolutely is. Yeah.

It's interesting because that's the perspective I hadn't thought of before.

I haven't interviewed in a long time either, on either side of that table, because I do work with businesses, mostly consulting work. And the last time I was interviewed, I actually remember I solved the problem, and I solved it in a way that I said, this is maybe not the best way to solve it, but it's a way to solve it. I think it's pretty good. There might be a better one. They said, what's another way? And I said, Well, here's a worst way to solve it, which is bit wise shifting. I think it was something involving mod two.

And they said, that's interesting. And I said, I don't like this way of solving it, though, because it might be more efficient. But it's also just not clear. They said, what's another way to solve it? And I had to think of another way. And it was an interesting process for me. But I do feel like that's an acquired skill in itself is the art of actually interviewing there.

Yeah.

And I always thought, actually, I don't have time for this, but I think it'd be cool to have somebody as a service do mock interviews for people.

You could even do it on Skype of like pretend you're trying to get a job here.

Let's do some practice interviews.

I like that because that's one of those I've told folks who I talk to a lot of folks who are getting into programming, either from coming from a code school running on their own, because I go to my local study group every week. And one of the things we talk about oftentimes is they say I'm not applying for jobs because I'm afraid to interview. I said, well, apply for a job that you don't want and interview there, because if it's the right problem domain, then you're getting practice interviewing by going to that job. And it may turn out you actually want to work for that company. You don't want to waste their time or your time, but go to a company that's a reasonably good fit but not your dream company and at least interview their first.

Yeah. Or even like the first time I tried something like that, I was a few years into my engineering career and a management position opened up and I applied for it. And I went through the internal interviews and a couple of them said, do you really think you have a shot at this? And I said, no, I don't think I'm qualified, but I want you to tell me why I'm not qualified so I can work on those things. So the next time a manager position opens up, I can be qualified.

Right.

But anyway, and you're doing all this in like a couple of pages, so I want to highlight this. Also, these email things are not time consuming. You can probably do them, try it over lunch and still get your sandwich eaten, and then think about it for a little bit. So you get it on Monday, try it at your Monday lunch, think about it for a while, try to get on Tuesday, and then you get the answer on Wednesday. You're sending the answer with all of this exploring it's just still just two, three, four pages of text is all good job, and I hope it's successful because I think it's great.

Awesome.

I would be happier if you also sent Pytz versions of those.

That is on my long list of features now to consider in the future.

And one of those things is that the fact that you just mentioned a short exercise, nobody really knows this because it's behind the scenes thing. But as I'm coming up with these exercises, I think I came up with a really good one. And then often what happens about half the time is like, oh, wait a second, I can't Whittle this down into a small enough format to fit in a good Python Morsel exercise. It's too long, and then I end up adding it to the list of rejected exercises. And I wonder if I'm going to end up making a B sides of this one day where I've got the longer ones, the shorter ones, that kind of thing.

Oh, that'd be awesome. There'd be people that are up for that, too. The weekend projects, right?

Yeah. Maybe months down the line when I have enough of them.

Yes. But one of the things I wanted to mention before we go, the thing I learned just this morning is if you have a keyword argument and you want to force it to be a keyword argument and not allow it to be passed in, not is the whole putting a star in the middle of between normal arguments and keyword only arguments did not know that was the thing.

Yeah, and that's something that I mentioned in the last blog poster wrote on keyword arguments. But a lot of folks kind of skipped over that section because they didn't they were skimming. The article went, I already know about keyword arguments, which you do, but you know them from the Python two world because that's what we're taught. Still, even though a lot of us are using Python, three is, we skip over that required keyword argument thing. So I actually wrote that article specifically, and a lot of my blog posts specifically for Python Marshall's folks to link to that explanation because it's something that we often don't get exposure to in intro courses.

Yeah, I encourage people that want to try to come up with topics for blogging. Also is when you get stumped at work and you have to look Google something to look it up, write a blog post about that because you just learned it, you need to solidify the learning. And that's a good topic for a blog post.

That is the best time to write a blog post. That's actually where all my posts come from is either I got confused by something or someone asked me a question and I tried to link them to an explanation and I couldn't find a good one. And then I went, well, wait a second, I could write an email explanation, but how about I write a blog post and link them to that instead.

And I'll usually try to do that down the line. So that is the best time to write a blog post. Absolutely. If you are a beginner and you are stuck on something, write a blog post and help someone.

That's the absolute best advice that I've ever given. That I don't follow myself, but I should.

Yeah.

One of the things you said, you don't address test driven development really directly in your classes, even though or you're teaching even though you're kind of doing that because you're writing the test for them anyway.

Is that on purpose or just something you don't want to dress or.

You know, it is on purpose. So learning good test practices while learning a new programming language, even if you know another programming language, it's like trying to learn this is folks in my study group have told me they're trying to do this. They're learning Python and they're learning Vim at the same time.

It's cool. If you want to learn Vim, it's great. If you want to learn Python. Learning them at the same time is difficult because you're not comfortable with your text editor, you're not comfortable with your programming language. You need to be comfortable with something when you're learning something new. So it's nice to separate the moment that you're learning about, say, Python and the moment that you're somewhat comfortable with that. And now you're learning about testing. Learning about the two things at the same time, I find to be a little bit overwhelming.

And that's actually a feedback I've gotten when I do try to teach test driven development on day one. Is it's difficult and frustrating for people to figure out how to write good tests while they are also figuring out how to write the programming language that they're writing the tests in. So it's a little bit diving too deep there, I think for a lot of folks.

Yeah.

It's separating learning one thing from learning the other.

Yeah.

How about in your personal work, we're just testing fall when you're writing your own code.

So in my own code, it's interesting because my own code, if it's a website, I want tests for the main flows that matter. But if it's a website and it's pretty static and I don't have much actual business logic going on, I actually don't really write too many tests. And this is a habit I picked up. It's not a great one because the world of testing on front end is changing that it's tricky to test for look and for feel when it comes to a website. And so because my own work is very web based, mostly because I'm working for myself, I'm not even really doing much consulting anymore.

I'm focusing entirely on training, for the most part for clients, which means my own code tends to be one off scripts, exercises, very small programs I make for myself, or sometimes open source projects. The open source projects have to have tests because I know if they don't, someone's going to get upset with me and open an issue on GitHub. And there's that peer pressure motivation. But there's also the motivation of I don't want someone running my code unless there are tests. If it's a real open source project there if it's my own website.

I actually don't have tests for some of my websites, not because I shouldn't write tests for them, but because I'm lazy and there's very little functionality. It is pretty much a URL, a view that does not serve up an HTML page.

So you don't even look at the website.

Well, that's a good point. I do look at the website. There are manual tests, and so you're absolutely right. I do have tests. I have a manual testing process, and it just go to the page, hit F five to refresh or control R to refresh, make sure it works, and deploy the website.

So you're right. I do have a testing process there, but it is a manual one by necessity, because writing the automated test for that, actually it would end up being less effective than my manual tests because I'd be able to check things easily, like 200 versus 404. But I wouldn't be able to spot check the copy and the CSS on the page as easily, right?

That's why I asked. That is because in environments where you have both manual tests and automated tests, there's this trade off that you always have to do is, are the manual tests more painful than the automated test?

What could break like you said, if it's a static site that's got hardly any business logic. For instance, on my blog, one of the things I'd like to add is because some of the articles are as old as like 2014 or even earlier, some of the links are gone. So I've referenced other things that aren't there anymore. So some sort of way to go through and check all the links to make sure that they actually end up in a valid web page. I probably should do that at some point, right?

What I'd like to have is something that could go out and make sure that the URL that I go to isn't one of those squatter sites that's just sitting there with a bunch of ads in it. Also, that's a good one.

Yeah, that's one that I was going to say here. I probably don't need automated tests for a while because we talked about this earlier, but I'm trying to kind of practice, I guess you could say a lean startup mentality of whenever I have a website or launch something new, I try to keep as few pages on the website as possible, as little unnecessary parts as possible, and so there's very few pages on my website, which means I don't really have much to check there as far as 404. However, I don't check any external links. I don't often click through on my old blog post to make sure they continue working years later.

Yeah, I don't get that unless. So that's one of the reasons I also have comments open is because people will tell me, hey, this link is broken.

That's the best test as an upset user who wants to let you know that something's broken.

Yeah, it's great. But anyway, and I also brought that up because I think that people need to there is some stress around testing this whole I should be testing more, but there's reasons to not if it's not going to break because you're using it all the time, you'll know it, or if somebody else is using it all the time and they'll know it and they'll let you know. That's a reasonable test process for some things.

It's probably not a reasonable test process for like launching a rocket or some heart monitor.

But for a website that's just got some information on it, that's probably fine.

For internal tooling, that's a big thing. Some of my clients will have something that is a whole bunch of code. It's only used for an internal process. No client's going to be unhappy when it doesn't work. The user of the product is very close or maybe the same person as the creator of the product. And so if something's broken, they know because they noticed it's broken in their own use of it.

And also the code doesn't change much because they're not stagnant products, but they change very slowly. And so their manual testing process only has to spin off every time a change happens so that those automated tests actually don't get too much. However, there are some things that are a pain for them to test manually when they're doing it. They could take those pieces, look at the tests that we've done in the exercises, and go, oh, I'm going to be inspired by this and write a test just for that piece.

Yeah.

One of the things I actually just talked with Anthony Shaw about the need for testing around DevOps tools.

So, like you're saying, a lot of these internal tools that people don't generally write tests for them because they're their only client. However, the impact of them breaking has a potential, like dollar loss, too, if they're trying to push out a fix or feature or something. And for some reason, the DevOps process is broken because one of the tools went down or requirement changed and they didn't push out one of the databases or files or whatever.

That really probably should have had some tests around it if there's a time or dollar impact to the company. But anyway, but especially for learning, I like more testing earlier in the process. So good job, Trey.

Excellent. Thank you.

So before we leave, any other bits and pieces you wanted to talk about before we.

I guess no, I didn't really mention my introduction that I do a chat every week for Python folks I may change the amount that I do that. Currently I do it every week. I have a mailing list thing. I send out the chats and the blog post and some other kind of useful links I find on the internet because I've got my own queue of kind of favorite Python talks and such and then there's always Python morsel this thing we talked about that I want more people using because I want more feedback on and so the URL I'll give for that is not pythonmorcels.com but the free one. Try pythonmorcels.com then you can just Google my name to find the other stuff trayhunter.com and I'm trayhunter everyone online because my name is unique so that was easy.

That's nice.

I'm glad you brought up the chat because I have actually been pointing people to that.

When I hear people occasionally I'll get people to say I don't have anybody doing Python around me and I'd like to go to a meet up and there's not meetups around here.

I say well you should just start your own or maybe not but I think the chats are a similar experience where it's an informal setting, maybe somebody's got a presentation but often it's a conversational tone similar to a meet up and you get the opportunity to ask experts questions and stuff.

Yeah, well it seems like it's me broadcasting a bit there but often people ask a question and I don't know the answer and someone else will chime in with answers and so people are talking to each other which is nice and sometimes I do bring on famous book authors like I brought on Brian Hawkin last year. You might have heard let's talk about his pipest book.

Yeah and that's definitely why I harangued you on pipes but hey I got to get back to work and you probably have things to do. So thanks a lot for coming on the show today.

Yeah, thanks a lot, Brian.

Thank you for listening and thank you to our sponsors talk. Python FM and Python bites FM the two wonderful podcasts that I think you'll like if you check them out.

Thanks.