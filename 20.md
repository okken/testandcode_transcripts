---
title: 20 - Talk Python To Me host Michael Kennedy
date: Fri, 29 Jul 2016 11:00:00 -0700
url: /testandcode/20-talk-python-host-michael-kennedy
---

Interview with Michael Kennedy from the Talk Python To Me podcast

<iframe src="https://fireside.fm/player/v2/DOAjrBV2+QmdnA6jN" width="740" height="200" frameborder="0" scrolling="no">
</iframe>

---
Transcript for [episode 20](https://testandcode.com/20)
of the [Test & Code Podcast](https://testandcode.com/)

<em>This transcript starts as an auto generated transcript.</em><br/>
<em>[PRs welcome](https://github.com/okken/testandcode_transcripts) if you want to help fix any errors.</em><br/>

<!-- 
For people reading this on GitHub, the final page will be displayed at https://pythontest.com/testandcode
-->

---

Welcome to Test and Codecode, a podcast about software development and software testing.

Hello, everybody. Feels good to be back in front of a mic again. It's been a while. Today I've got Michael Kennedy, D. Michael is the host of Talk Python to Me podcast. He's also the creator of some great online courses to teach Python. There are two courses done, and one that just launched as a Kickstarter campaign. And by the way, we're giving away copies of these courses to sign up, go to Python Testing Netsubscribe and sign up. This podcast is not sponsored by Michael. I just believe in what he's doing and I appreciate what he's added to the community with his podcast, so I wanted to talk about that with him and talk about the course.

This podcast is also not sponsored by Pie Charm. Although Michael plugs it heavily at the end of the episode, I probably should have asked them for some funding since he plugs it pretty hard. Speaking of sponsors, though, robust sponsored episode 17 and 18. That was really cool then.

So thanks, Robar. If you'd like for me to plug your thing, visit Pythontesting Netsponsor and get in touch with you. This episode is supported by Patreon supporters. Thank you, all of you. Patreon supporters visit Pythontesting NetSupport to get me to do more episodes. Yes, more supporters, more episodes. It's kind of how it works.

So this episode during the episode, we talked about several of the episodes on his podcast, Talk Python to Me, that involve testing, which is pretty cool, except he didn't bring up the episode where he interviewed me, put links to that and all the episodes we talk about and his courses, which we also talk about and his podcast, all that in the show notes. The show notes will be at Python testing. Net 20.

Today we've got Michael Kennedy from the Talk Python to Me podcast.

Michael has been, like, really great to try to encourage me for my podcast, and he started up just a little bit before I did and has been helping me out whenever I have questions.

And it's been great. If anybody on my audience has not heard of Michael Kenny and the Talk Python to Me podcast, tell me, Michael. Tell me a little bit about it and who you are.

Hey, everyone. Brian, thanks for having me on the show. My name is Michael Kennedy. I'm the host of Talk Python to Me, one of the Python podcasts.

And I've been interviewing a ton of people in the industry and really trying to spread the stories of the Python community, including a bunch of ones on testing, which we'll talk a bit about.

We both interviewed Harry Percival.

Yeah. We both had Harry Percival on the show. That's right.

Yeah.

He's a great guy.

What other testing episodes have you got?

Yeah. So I talked to Harry Percival and he was on the 10th show or 11th, depending if you are zero based or not. And he was on the 10th real show, let's say, and we talked about his book Obey the Testing Goat and his website and all the work that he's doing there. So we had a lot of fun with that and talked about his Python anywhere company that he works for and works with.

They're doing really cool stuff. The other two that I did are more recent episodes and those were within the last month and a half or so I talked to a guy named Austin Bingham and Austin I know from some of the conferences that I speak at and traveling around and stuff, we seem to run to each other in London all the time. But being here in Germany for the year, I'm going to a couple of different conferences and he and I were both at NDC Oslo. So the conference up in Oslo, which was really cool to be up there and see that place is somewhere I've always wanted to go. So I ran into him and he was doing a presentation on something I had never heard of but was really fascinating called mutation testing. So you and I have, we've joked about whether unit tests are good things and what they are. But everybody has this concept of like unit tests, functional tests that you're going to run against your code, right? So I want to prove some functionality works. I'm going to write some tests that's going to exercise that code and assert some things, try to make it through exceptions and verify that.

So how do you know those tests are good? The traditional answer has been code coverage, right? So if I went and I told you, hey Brian, I have this awesome project and it is so super tested, you won't believe how tested it is. It has 1000 unit tests, right? That statement alone doesn't mean much, right?

Not to me really.

But I know it does.

But if I said it has 1000 unit test and it has 92% code coverage, that's a stronger statement, right? Regardless of whether it's like something you should aim for or whatever, it's definitely stronger to say I have these tests and they have some level of coverage, but there's a difference between executing code and actually Test And Code. So this concept of mutation testing that Austin is building the Python libraries to facilitate is what it does is it looks at your code, you have your code and you have your unit test and then you apply this mutation testing. And what it does is it will fiddle with your code. It'll take your real code under test and it will change a little bit of it. Like if you have a test that says if the number of users is greater than ten, it'll possibly switch that greater than sign to a less than or it might replace a variable being passed to a method with just some constant or some other modified version of the variable and if they could make those changes and your tests still pass. Well, your test must not actually be verifying that bit of functionality, even though it may have covered it. So that's a really interesting idea of this mutation testing.

Yeah, I think the combination of the mutation testing and then the translations, the different input that hypothesis does, and combined with some code coverage, it's interesting.

At least it's definitely interesting. Yeah, the other one. Did you have David McKeever about hypothesis on your show?

No, I haven't.

Okay. Yeah, he's a great guy.

He approaches this automatic sort of testing story from a different angle from the property based testing side. So instead of writing traditional, I struggled with the words the Newman Glacier of it when I first learned about it. Like, well, if we have traditional unit tests, we have this other way of testing that also runs the unit tests. Well then what the heck do you call the original ones? And so what it seems like people are settled upon is example based testing. So like if I want to test, I can register a new user, maybe I've got a call function I got to pass like a name and an email address and a traditional test I would pass like an actual concrete email address and a real username or something like this. In the property based testing with hypothesis, you just say I need a string, maybe formatted like this regular expression. To go into this email field. I need a string to go into the name and maybe I need a number to go into some numerical field and then the system will automatically vary the inputs and choose the examples for you and try it with sort of corner cases. Like for example, it might pass none for the email address, whereas you might have never tested that. It really is a very powerful way. I haven't had a chance to do a lot with it because the idea is kind of new to me, but I'm pretty excited about it. I think it's actually cool.

Yeah, I haven't looked with either of these yet, but some of those cases that you brought up of different types of input. And what are some of the special things that you might pass in, like the empty string or none or things that aren't strings, or Unicode or splitting up your input into interesting sets of input? Those are pretty cool.

Those are really cool. And it seems to be pretty clever. I think it might be more exhaustive, but just detect the clever bits, but it seems to be really good at sort of finding the edge cases. So if you have some function it's logged to take one through ten, it would probably find an error when you pass an eleven. And instead of going like well, it seemed like 1246 didn't work. It would probably say eleven didn't work. And if it's like a series of steps it has to take to find that it'll actually give you the steps to reproduce your bug. So it'll say, well, first I created this thing and then I passed this variable and then this value, and then I called this function and then it failed. And that's pretty awesome.

Yeah.

It'll discover the steps.

The thing that hurts my head to think about these things is trying to figure out where I put it in my workflow. Like, do I write those ahead of time before? I mean, mutation testing. I clearly have to have my source code first.

And hypothesis is doing what did you call it, like example based testing?

Example based testing is what we're calling it.

Yeah.

When do I do that? Do I do it during development?

Does the QA team do this?

Well, I would say that those two projects are both super interesting and they come at sort of solving this problem of how good are your tests, either from automation on the hypothesis side or actually tweaking things and see what's detected on the mutation side. But I feel like the hypothesis bit hypothesis library is further along in practicality.

So there's a real complexity to vary every bit of your code and do that in a performance way. With mutation testing, they got some good progress on making that faster. But it's also I think that's something that comes later in my mind.

Austin may disagree with me on this, but I feel like that comes later. But if I was starting a new project and I were writing tests, if they were nontrivial, I would probably use hypothesis. I say probably because I haven't really started a new project since I've learned about it. So I haven't really had a chance to make that experiment to see how that goes. But it seems pretty much as hard or as easy as the traditional testing, but it has this ability to cover all the edge cases, so it seems like the payoff is high.

Yeah. I probably should talk to these guys, but I'd like to talk to somebody that's using this for a production system and to try to find out how they're using it and who's writing the tests and stuff like that. Yeah.

I think there's a few interesting examples.

I don't know who the developers are, but I think David talked about hypothesis being used at Twitter. I could be wrong about that. But, you know, some pretty cool examples that he has some high profile companies making use of it.

Okay.

Hey, we skipped over something I wanted to talk to you about. One of the things I wanted to ask you about is your transition.

You used to be like nine to five. Well, not really, but you used to work for somebody else and now you don't.

Yeah, I used to be like a nine to seven person, and now it's even worse. Yeah. So actually, that's a big deal for me. I've been for many years just an employee company. I've been doing training and I've been doing scientific software writing and all kinds of things, but I've always done it for another company.

And for many years I've wanted to start my own project. But having kids and a wife and mortgage, it always seems really not worth the risk. You know what I mean? It's like it'd be really fun to go do this thing, but eating is fun, too.

The podcast, when I started it a year and a half ago, really took off much better than I expected, way better than I expected. And I never really had huge plans for it because I didn't expect it to do a lot. But it did take off. I had a lot of people wanted to come and support the show. I've had a lot of great companies come on and sponsor the show, as well as a ton of people listen to the show. So I've been sort of trying to decide, well, what am I going to do?

And I thought the thing that I could do that would really contribute to the community that I think would be reasonably valuable and unique would be to start creating a bunch of online courses that people that listen to the podcast and get super inspired about whatever it is we're talking about. For example, hypothesis. If they wanted to learn more about it, it would be really great if there was like an awesome course that followed onto it. Right.

I launched a company and I started creating online courses, and I'm on this mission to create my original mission statement was create 20 online Python courses that are sort of unique and special. In two years, I'm sort of on track. Maybe it'll be 15, but I'm definitely working to create a bunch of really cool Python courses. And so in February, I quit my job. I launched that first course on Kickstarter. It went really well, and I've been pretty much writing online courses since then.

I've been enjoying watching the course of your courses, the progression of how your courses are going, partly because I'd like to try to put together a course at some point myself, but also because I always run into people that are trying, like I said, trying to use Python and trying to use testing or even just Python. And they're experienced programmers, so they want to jump in like really fast. So I'm always on the lookout for ways for people to learn this stuff quickly, especially the combination of your first two courses, I think would apply. That's why I'm really excited I wanted to have you on because this combination of the first two courses, I think that they'd be great place for people to get up to speed quickly and get on with their jobs.

That's cool. Thank you so much. Yeah. I mean, the goal was to take people who know some programming of some sort it didn't really matter what language, right. If you knew JavaScript, if you knew C plus plus, whatever. But to get you up and running on Python really quickly, but also in a way that after you went through the courses, you fit in, you felt comfortable in the language, and so on. So I started out building my first course, which was Python jumpstart by building ten apps. And there's a ton of Python courses and tutorials. And the problem that I see with so many of the online courses or even non online courses, the courses is you teach people a ton of facts and then it's up to them to put it together. Right. So maybe if I was doing some kind of class, I might say, okay, well, today we're going to talk all about language ideas. We're going to talk about loops and strings and functions, and we're going to just talk about all the details. And you guys are grown up. You'll put that together and something interesting, I'm sure. Right. And you'll somehow remain motivated through this whole thing.

And I think that whole process of teaching that way or learning that way strips the joy out of it. I think it filters people out who don't see the end of it as having enough of a payoff to sort of do a suspension of disbelief to work your way through all these little facts and details until you get there. So what I said is maybe I'll do it backwards. Like maybe we'll just start writing apps and if we get to a thing that you don't know, well, then we'll stop and we'll talk about it for a minute and it will just keep on writing the app. So my first course is like 7 hours of just like building ten different applications with little intermissions where we spend like five minutes on some idea, like five minutes on talking about the structure of classes, and then we go build like a DND game with it or continue building a DND game.

I like the model I watched through those videos and that sort of a model. I know it makes sense, I know, to go through a project and learn while you're watching the project happen. But I've seen it in book form and in book form. It drives me nuts. I don't know why it just bugs me, because I want to see the reference in a book, but in the video form, it works great. And then I can use some other reference to look up all the details.

Yeah, I'm glad this works for you.

I kind of envision. Like, what would it be like if I sat down with somebody who was a competent programmer of some variety but knew nothing about Python? What would I do if I sat down with them for a day or two and just like we work through some examples together? That's kind of what I was hoping to achieve.

Yeah.

I think you hit it. I'm actually going to try to do. I've got some projects at work, actually, that we've got some tools that people don't really know how to use. And there is training available online in other places, but they're huge. And I just need these people to learn, like a couple of different features. So I was going to try to do like screencasts and with a voiceover just to kind of walk them through it, and then they can rewind that.

It's a great idea.

Yeah.

So the model of if you had Michael just sitting next to you teaching you, this would be what it be like. And so one of the things that I really like is the second course with the Python. What's the title of the second one again?

It's right. Pythonic code. Like a seasoned developer at work.

We started using Flake Eight. I think that's what we're using.

Yeah. It's a nice one to try to streamline and automate some of the style stuff. But I wanted to get people to be able to write more, better code.

Yeah.

I think one of the thing that's interesting is when people are new, I feel like they focus on Pep Eight. And those of you who don't know what Pep Eight is, the Pepsi and Python or Python enhancement proposals. And Pep Eight talks about, like, the way you should format and structure your code.

But it turns out that that stuff is pretty easy. That stuff tools will talk. The tools will address like Flake Eight and Pi, Flakes and Pilot. Those types of things will tell you, oh, you're supposed to name your variable this way or all your function shouldn't be uppercase. Right. That kind of stuff. But to be sort of really comfortable in Python, you got to go to the next level and you've got to understand almost the design patterns of the language. Yeah.

So what I did was I said, all right, well, let's see if I can put together a list of some cool stuff that might be interesting for people. And I wasn't necessarily sure it would be a class. I was just going to talk about it somehow. And I came up with after a little bit of research, I actually came up with 30 different little design patterns and Idioms and so on, like, okay, this is pretty cool. And actually in the end, my class has, I think, 52 right now. Maybe it'll get more later, but 52 little programming examples of do this, don't do that.

And this is why in Python I know it's different for everybody. In my case, I see a lot of code that looks like C Code. And so trying to have somebody get look at some of these different patterns to see, oh, yeah, I can do it.

When you're in Python, do it different. Don't write C Code in Python.

Yeah. That's one of the real challenges. Is it's kind of a blessing and a curse from Python. Of Python. It's so easy to read and learn that people come from other languages, and I feel like they don't take it seriously. They don't take Python or learning Python seriously. They're like, oh, I see. Okay, so no curly braces and colons and indentation.

Cool.

So let me go right my while loop like I would in C, or let me write my getters and setters like I would in Java or something like that. But just because the language is easy to pick up the basics of it quickly, it doesn't mean that you should just take these algorithms and move them over. Right. And there's usually a much simpler way, something that's more like in line with the way C Python itself will try to understand and execute the code. And so on.

Some really powerful examples of when you see the differences next to each other, you're like, oh, wow, that's so much better.

Right. But if you don't get those concepts, then you're missing those really great opportunities of why Python is special.

So speaking of Python being special, we do talk about Pythonic code and Python style more than we talk about it in C, for instance. That I don't know. But at other languages. Any ideas? Why do we care so much in Python?

I think I do agree with you that other languages don't care as much.

Not to say that they don't care. Right. They certainly do have their own styles and idioms, and people do care, but they seem to care more in Python. We have a name for it, right? Yeah, we have Pythonic code. We don't just have like Python code that fits in or Idiomatic Python or something. We have a special name for it because I think it does matter more. And I've been thinking about why that is. I think it may come down to a handful of reasons. Two or three. One is what I was kind of talking about before is like, Python is so easy to get started because it's such an easy language to learn if you're just going to kind of like Port your knowledge to the syntax. But it actually has a bunch of really interesting ideas, generators, comprehensions, tuples, foreign loops, all these things that there are other languages, they don't have them. And if you really understand how to use those building blocks, then you can create something different and better and more readable and more maintainable in Python. So I think that because people so easily come to the language.

But they don't easily actually become comfortable in the language learning some of this Pythonicness and style. It helps people actually learn how to program in Python better than hopefully.

Oh, yeah. I would say it certainly is less error prone for many of the ways you might do it. Right. Just take an example.

There's not really a numerical for loop in Python. This is like a super simple example. If you know Python, you know this, right?

Yeah.

If you didn't know and you're like, well, I need an incremental number type thing.

So maybe you'll make a variable and assign it zero, and you'll do a while loop, and inside the loop you'll do a plus, and then you want to get data out of a collection. So you'll index it out by ID or by index. There's chances that you get those indexes wrong, that you do less than versus less than equal on the link and all that kind of stuff. So there are cases where you buy introduced bugs, whereas if you just for item in collection, work with item unless you screw up the syntax, that can't go wrong. So I think it's important because it makes your code less error prone, not just more readable.

Yeah.

On the two courses, the first course goes through these different applications. Your second course doesn't build an application. I think it works. But was that intentional or just happened to be that way?

Yes. So the first course, the primary goal was to take people who don't know much or anything about Python and get them pretty proficient in a way that will keep them engaged from beginning to end.

Right. And so the way that I thought, okay, the most important thing to do is that you're constantly building something cool and you're seeing progress. And we'll periodically take breaks and talk about the more like theoretical bits or whatever. Whereas the Pythonic code that's made for people that already know Python, you've been doing Python for a year or two, and then you're going to come check this out, maybe six months, but you're not new to Python when you take that course. And so I felt like we have 50 things to cover and you are already inspired and comfortable with Python.

Let's make it more of a reference thing. Right. So if you want to be able to jump back in and go, oh, what was that design pattern where we did this cool dictionary merge? There's like a two minute video. That's all you need to look at for that. Or what was that thing where we actually use generators so that we could make it so much faster? Oh, yeah. That's this little section. So I kind of wanted it to be a reference that you could jump around. But also I couldn't come up with 50 apps and still get a practical well.

I think it was a good call anyway, because even if you had done apps, I think, like you said, it's aimed at more intermediate developers. So they're not going to do the application anyway. They're going to apply it to whatever thing they're working on.

Right, exactly. I feel like they need less context and more focus at that place. So that's what I tried to give.

Yeah.

And then like, wow, you just came out with a third course.

Yeah. That was yesterday it's been announced and sort of running on Kickstarter for a whole 28 hours or something.

Well, I'm actually pretty excited about that one. It's for entrepreneurs, right?

The title is Python for Entrepreneurs. And this is something I wanted to create for a really long time, but I wanted to make sure that I had these other foundational things in place where people are like, well, I need a little more help with this or that. Like, okay, well, you can go over there and learn when you're ready.

Come over here and we'll build something awesome. So it launched on Kickstarter yesterday. And the idea is if you want to make some kind of online business based around a web app or something with a web API, some sort of core web technology, you're going to have to build that thing, right? You have to build the web app. So let's just say you're building like some kind of paid email service. You have to build the thing that is the email. It's going to have to store database and manage user accounts. But when you actually go to try to launch that thing and turn into a business, there's like a zillion little loose ends. And I've done this a couple of times. I've built some online businesses that were successful. And I feel like building the app itself is like 30% of the work, maybe 40%. But you've got all the stuff, all the technical programming stuff that surrounds it, right? So you've got to accept credit cards, you've got to store user accounts, securely hashing the passwords in the right way.

You got to do outbound email. Like when a user buys something and send them a receipt, if they forget their password, reset it. You got to do inbound email with domains, SSL. I could go on and on and you got to do deployments.

It's never ending. And so the idea is to try to cover those in a way that it's not like a six month research project, but it's like a two week tie up. The Lucian project.

One of the exciting things is it's got a pyramid tutorial, and I've always wanted to try pyramid.

I do think it gets underappreciated. I just did an episode with Donald Stuffed. Well, just like a month ago, number 64, if people care. And he's in charge of PyPI, the Python package index and all the packaging stuff, right. The website, Pi, Python.org and so on. And they are rewriting that it's like super old, super clunky. And it's getting a rewrite. And it's actually the rewrites, like in a beta type thing at Pip. Io, I believe. So people should check that out. That's really cool. And he talked about how he started out in Django, and Django was okay, but he didn't want to use a lot of the building blocks that is sort of paradigm preferred that you use, let's say. So he felt like he was fighting the framework. He then switched to Flask, and Flask was better, but it wasn't quite doing what he wanted specifically around testing. Actually, he felt like he couldn't test his apps as well in Flask. And then finally he switched to Pyramid. And now Pip is now getting its final touches put on. It built on top of Pyramid and my web apps as well. One of the reasons I chose Pyramid, even though maybe from a pure popularity contest, I should have chose Dango in my course. I want to make this super concrete and super real for people. I don't want to talk just in theory. Like, yeah, you should do this type of processing for credit cards or you should do this to monitor errors. I want to make it really concrete. So during the course, I'll open up my training site and say, look, here's how I'm accepting credit cards. When you bought this course, this is what happened. Here's how the email went out. Here's how you got put into the mailing list. Here's how you're stored in the database. Here's how I hashed your password in a way that if somebody stole the database, it's highly unlikely they could do anything useful with this and so on. Right.

I think that's incredible. And I think actually I'm definitely going to try to watch this course, but I think it probably would apply to people that even if they don't want to do it themselves, actually, just to see all of the little details you got to go through, I have no idea how you guys fit it all into one course. Is it like 97 hours?

I think it's going to be longer than the other ones.

I think it's probably going to be 15 hours, is my guess. But yeah, it's definitely going to be longer. I think it's not just for people who want to become solo entrepreneurs like you say it's certainly if you are going to hire a consultant to do part of your app, you would know, I see. This is what I want done like this. Can you just help me do that? Right. It's also if you work at a business, let's suppose you work at some big megacorporation and they're like, all right, you and those two folks over there, you guys are going to launch this new online endeavor for us, right? If that's your job, then you basically need to do the same thing like that I did to launch my business, or a lot of people did to launch their online business. Well, that's the kind of person I wanted to help.

Yeah, I think that's great. I think that whether you thought of this or not, you probably did. But some of the people that are helped by this, they're not going to do an external website.

It's something to pass information around within a company.

There's not a budget for hiring people.

It's got to get done fast. And you only have like one or two people doing it.

Yeah.

I feel like people get super excited about either projects or starting some online thing and they go and they build it and then they launch it and it just kind of sputters out or it never quite gets launched because, oh, my gosh, I'm on the 20th extra little item that I hadn't thought about.

How do I set up NGINX to reverse proxy over to microscopy to run on digital air or whatever. Right. Like, I didn't know that was the thing I needed to know in order to create my for sale by owner for boats company. But apparently I do. Right. So hopefully I can help the world not suffer through those things.

We'll see.

Cool. Well, I wish you luck on this. Let's see. I think I had some other things.

Oh, yeah.

One of the things I wanted to talk about was the courses that you've done are in Python three. So are they completely useless to people using Python two?

Yeah, they can't use it. No. Steve, for example, I looked at certainly the jumpstart. One, there's very little differences and there's a few things that you can do to make those differences even smaller. But even the idiomatic one, there's a couple of items that don't make sense for Python two developers. There's a couple of items that don't make sense for Python three, three developers, for example, Python I think it was three four could be three three or three four introduced yield from, which is really great for working with generators, building recursive generators, let's say. And then 35, they introduced some special sort of dictionary building syntax. And those pieces that talk about that, they don't make any sense. But there's like 48 other ones that totally do. Right.

You might want to do.

I must have missed those because actually we've got both Python three at work. We're using both Python three and Python two for different purposes.

And I think all of them apply at least all the ones that I really care about people understanding. And it's pretty easy to figure out if you try something out and it doesn't work, it will encourage you to try to figure out why you're using Python, too. If you really need to, then move to three. If you exactly.

I mean, there was a few things that I didn't address that you could maybe mentioned in passing. Like, for example, I talk about range using range with foreign loops for sort of numerical processing and incremental processing of one to three. So on. And range is considered dangerous in Python two. And you should use X range. Right. Those things that maybe mentioned in passing or old style Python two classes versus new style Python two classes, which are basically Python three classes. But the thing to think about, I think, is really interesting. Brett Kennen and I talked about this for a while. He's one of the Python core developers on the episode that he was on in 2020. Python Two is going to be end of life now. To me, the year 2020 feels like it could be in science fiction, some sort of science fiction future. Like there could be robots that look like humans roaming the Earth and flying machines. But that's not the reality. 2020 is in like three and a half years, and then Python Two is gone, and it's not.

You've got to start thinking about Python Three. Then you have to have completed your upgrades to Python Three in three and a half years. So if I'm building online classes and they're going to have any sort of applicability going forward, I kind of felt like one from just an investment perspective, it makes sense to invest my time in Python Three stuff. But also I feel like I would be doing something of a disservice to the community to continue to encourage Python Two.

Yeah, I think so, too. I'm doing the same thing. I'm writing some new instructional content, and starting in Python Three, I'm going to go back and see how much of it needs Tweaked to run in.

How about your book?

Yeah. So the first edition of the book was the one that's out on sale right now is written for Python 2.7, and a lot of stuff doesn't work in 35, which is a bummer. Mostly print statements, actually. I think that's it. I think I just riddled the whole thing with print statements, and I didn't always remember to do the right from future import print function.

Yeah, print. Yeah, exactly.

It's unfortunate because conceptually, that's a meaningless difference. It means nothing to you whether you have to put parentheses or not parentheses in your print statement. But it also means that if somebody picks up that code and tries to run it in the Python Three app, it doesn't work. It's frustrating. This doesn't work.

Print thing is malformed or whatever, right.

Some of the esoterics about two versus three and versions of two and versions of three I don't really care about.

And for most code, doesn't matter.

The notion that you should use in some versions of Python Two, you should use X range instead of range, because X range is a what is Iterator?

Generator. In most code, it doesn't matter. In most code that I deal with, the computers got tons of memory. Making a list ahead of time could be fine.

Yeah. If I have ten items, I don't care if it's a list or generator, it doesn't matter. Right. But if you're doing data science, you may care.

Yeah.

It matters.

I cared like testing instruments. I had to stick with two seven for even a year ago because the library I used to interface with the instruments was not on Python Three, but now it is. So. Yeah.

Hey, that's awesome.

What did I want to talk about? I wanted to talk about a few more things.

I think everybody should check out your stuff. I think it's exciting.

Definitely subscribe to the podcast. But also for me, I think if you're kind of just a nerd and like to learn stuff, your third course, Python for Entrepreneurs, sounds really exciting, but I think everybody should go check out the second one, even if you're experienced Python. And I think that's worthwhile for everybody.

How do people find out about this stuff?

Where is it again?

Well, yeah. So the website for the podcast is Talk. Python. Fm.

There's a training sub domain, but you don't really have to know about that if you want to go check out the courses. The first beginner course is Talk. Python. Fmcourse.

The Pythonic one is Talkpythonpythonic and the entrepreneur one, Islaunch. And that's all you need to know.

Okay.

And I'm going to put you on the spot and ask if we can give away a copy of one of these courses.

Yes, I would love to give away a copy to some of your listeners. So. Absolutely.

Let's give away a copy of one copy of each. How's that?

That sounds great. And I will draw those. I should probably put some limits on it. Whenever this goes out, I'll put some information at the end, but I'll give everybody like three weeks to sign up and then I'll give it away.

Yeah. Beautiful. I'm happy to do it.

That sounds too long.

Whatever works for you. That's cool.

How long do you usually give people?

I usually give them a week.

Okay, let's tighten it up. One week, man.

Don't mess around. You got to act. Yeah. Or miss the opportunity. Right?

Yeah.

How do they sign up?

Well, I've got a mailing list.

So sign up at Python testing. Net. Right.

Pythontesting netsubscribe.

Awesome.

And I'll pick one person out of my email list, I guess as many copies as I got. So three courses. Three. I'll pick three people.

It's good.

Perfect. Yeah.

You are moving to Portland. I can't wait till you get back. We've met twice, so we've had lunch together, so we've only shared beers twice.

Seems wrong.

Definitely wrong.

So I'm glad you're coming back. If anybody has listened to your show before, you always ask people about their favorite package and what editor they use. So I'm going to ask you.

Excellent.

What pie Pi package would you recommend to somebody?

So there are so many popular ones, but I always try to ask that question to highlight things that are maybe not the first thing that comes to people's minds. And so one of the things thinking around this entrepreneur, of course, one of the things that just boggles my mind is every time I want to create a new major website, I have to reinvent user management.

I know they're sort of like built in, pre built things, but it always seems like, okay, that's close. But that's actually not there's something different about this time that I got to create user accounts differently the packages I really like is this thing called Passlib P-A-S-S-L-B. So one of the challenges is if you take the username and the password and you put it straight in the database and somebody gets a hold of your database through a SQL injection attack, little Bobby tables, or if they somehow just like, maybe you lose your Dev laptop and have the data in it. It doesn't matter how the database gets out in the world, right? If it does, that's super bad. Right. So the recommendation, of course, is to hash your passwords, and the real recommendation is to hash your passwords with assault. So you would take the password from the person and some other text that you consistently use for that person but is unique to them. And you put that into a bit of sort of merge that together somehow and then you hash that result.

And then in the future, when you come and you check for the password, you kind of redo that to whatever they enter and you say, is that the same hash?

Yes.

Okay, great. Well, it turns out with the ability to go to Amazon AWS and get like GPU clusters, doing that once is not really enough. You actually have to fold those over and over using powerful algorithms. So maybe I need to do that, but then take the output and feed it back into the cycle like 50,000 times so that it's actually computationally hard to answer that. So figuring all that out, figure out the right balance, the right algorithm, storing the unique salt in a way that's not obvious. All those kinds of things is really challenging. And Passlib solves all that.

Oh, cool, because I was already lost.

So, yeah. So if you want to store passwords securely in a database or really anywhere, I guess. But typically that lands in the end in a database password. Okay.

Do you talk about that in your entrepreneur course?

Yeah, it's definitely going to be in there.

Okay, cool. And if you want a program, Python, what editor do you use?

Almost always. Pycharm. I love PyCharm.

I guess that would put me in the camp of an IDE guy. But I find myself doing web development where there are many files that somehow come together to make a web app. Maybe there's 50 PY files and ten CSS files and five JavaScript files and so on. They all come together to mean like something coherent. And what I think is great is Python understands all of that. So if I go and I rename like a function in some script, some Python file, it will apply that to the whole project. Right. It understands where it's used, does all the fancy stuff for JavaScript, for CFS and so on. And also it understands a lot of the Python Idioms.

So I'm trying to think of some examples right off the top of my head that it does. It certainly does Pep eight, but that's pretty obvious. It actually does more than that. It will say, oh, this way that you're Test And Code, you're testing some condition for an if statement.

This could be more Pythonic. If you did it this way they automatically fix it. It also has great testing for your audience. They might like that. Like it has built in code coverage and so if I go and run the tests against my web map, like the entire project tree will have little percentages by it. This file has 47%, that file has 68% and I opened the file. It has like color the lines green and red for the ones that were run or not run during my test. Like all those things add up to be awesome. So PyCharms my answer.

Okay, cool. What if you're writing a letter to your grandma or something like that?

Writing a letter to my grandma.

Google Docs. I kind of live in Google Docs.

Really?

If I'm not, I really like Google Docs. Yeah, I like just that it's not on my computer. I have this policy that my computer should be smashable.

It's a MacBook Pro. I don't want to smash it, but that's part of my thing for code. It lives on GitHub for writing that lives on Google Docs. But if I'm doing something else, it's probably sublime.

Okay. Yeah, I converted this sublime recently, I guess not really recently. A few years ago. And yeah, it works for me.

Yeah, nice. Right on.

But I also live half the time in the command line with Bash.

Yeah, the drawbacks of depending on the ideas like PyCharm, which I do love them, is if I have to SSH into my server, I'm on my own.

I do want to try PyCharm again.

Half the time I'm looking at C plus plus code so I'm not sure if that handles that well. So we'll see.

Of course.

Anyway, thanks a ton for coming on the show and I Wish You luck and love To Have A Beer Or Something when you get back.

Yeah, I'll be back next week from Jet lag, so give me a few weeks. We'll definitely meet at Thirsty Line or something. Brian, thanks for having Me On the Show. It's been great.

Okay, so again, talk Python FM and that's how people see it.

Talk Python. Fm. Yeah, is the jump off point for everything. They should check out at the top Python space.

All right, that wraps it up. Thanks a lot.

All right. Thanks. Bye bye.

Thanks, Michael. Don't forget to go to Python testing netsubscribe and sign up to win those courses. Thanks a lot for listening. Keep calm and write some damn Yes.