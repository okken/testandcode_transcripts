---
title: 91 - Python 3.8 -  there's a lot more new than most people are talking about
date: Wed, 16 Oct 2019 00:15:00 -0700
url: /testandcode/91-python-lot-new-people-talking
---

Python 3.8.0 final is live and ready to download. This episode covers what's new, including new language features, standard library changes, and optimizations. Not just the big stuff everyone's already talking about. But also some little things that will make programming Python even more fun and easy.

<iframe src="https://fireside.fm/player/v2/DOAjrBV2+qSJUopZC" width="740" height="200" frameborder="0" scrolling="no">
</iframe>

---
Transcript for [episode 91](https://testandcode.com/91)
of the [Test & Code Podcast](https://testandcode.com/)

<em>This transcript starts as an auto generated transcript.</em><br/>
<em>[PRs welcome](https://github.com/okken/testandcode_transcripts) if you want to help fix any errors.</em><br/>

<!-- 
For people reading this on GitHub, the final page will be displayed at https://pythontest.com/testandcode
-->

---

00:00:00 I've been trying Python 3.8 during the beta releases, cause I'm that kind of guy, but it's no longer in beta. Python 3.8 .0 final is live and ready to download. Yay. On today's episode, we're going going to run through the What's New Doc that the Python.org team put out, picking out the bits that I think are the most interesting and affect the most people, including optimizations in three, a porting to three, a new language features, standard library changes, and a cool little benchmark demo. Are you going to upgrade right away? I'm going to I'll jump in with both feet with small projects and for large projects, of course, a careful approach with test. Of course, I'm excited about Python 38 and really this episode is my way to try to get you excited about it, too. Thank you to Patreon supporters for your continued support of the show. And thank you, Pie PyCharm for sponsoring this episode. They've done a bunch of cool new things lately. More on that later. Now. Python 38 welcome to Test and Code, the podcast about software development, software testing, and Python.

00:01:26 All right, Python 38 is now here, so if you go to Python.org, you can download it. I've already downloaded it for Mac and for Windows. Yes, I work on both of those. I have not tried it on Linux because I'm currently not working on a Linux machine, but I know it's available for there. What I'm going to go through today is a document. That's it. I'm going to have the link in the show notes, but it's docs python.org. Three point eightwhatsnew 3.8 HTML. That's pretty easy. So we're going to go through a little bit of optimizations, a little bit on Python, porting to Python, and some of the new features that I absolutely love and can't wait to get my hands on. Actually, I already have my hands on them, but can't wait to play with them more. Some of the standard library changes and cool benchmark demo. Of course you can read this document, but it's or the what's new thing? It's kind of long, so I thought I would try to help out with kind of going through it for you. All right, I got some notes here for when I installed on my Windows machine. I've got a Windows Ten machine. I installed it on just today, actually, yesterday. What are my notes say? Sometimes I forget to do this, but when you install it on Windows, just the default install off of Python.org, I think it's a good idea to go through the advanced options and click Add Python to the environmental variables so that you can just it's just there. It's just my recommendation. Sometimes I forget to do it and I always regret it.

00:03:00 I know how to edit my own environmental variables, but I'm lazy. I just reinstall it and click that check box. Also, as a reminder, you can run multiple versions of Python at the same time I just deleted 36 actually to try to have less installs on my machine. I'm currently have three seven and 38 both on all of my machines, as I'm going through the transition to three eight to make sure it all works. And there's lots of ways to do multiple versions on Windows, at least I'm trying out the Pie thing. Another option in the advanced install is a thing called pie that allows you to run both versions, but I think it'll be just a short while. I have two versions on my Windows machine, I'll probably switch to three eight pretty quick optimizations. There's actually a really long list of optimizations for 38, so what does that mean? Well, I'm going to break this down into a little bit of a bullet. My take on the whole thing is there's a whole bunch of time and memory optimizations in three eight that should in general make all of the code that you used to run on 37 run faster on three eight, also with less memory. So there's memory optimizations and time optimizations. Very cool. That's my take on there's a section in the document about porting to Python 38. I think that just know it's there. I would recommend that's what I'm doing, I skimmed through it, read it. If you run into any issues. I didn't see anything in there that would cause me concern for what I'm usually doing. And I do some wacky stuff, but I would take a perusal. Do you upgrade it? Maybe in a virtual environment or a side branch of your code? Try it out and see if there's anything. If you run into anything, I'd be curious about it. Let me know what sorts of things you ran into, but the in the porting section, one of the things I'm excited about is there's a new syntax warning. Why would somebody be excited about that? But this is cool. The compiler now produces a syntax warning when identity checks like is or is not are used with certain types of literals, like strings and numbers. These can often work by accident, but are not guaranteed in the language spec. So, like, is one really you're supposed to use equal, so it's got a warning that will tell you to use equal and not equal instead. So that's cool. Okay, definitely the fun part. I want to talk about all the new features. So yeah, that is exactly why I'm upgrading. I guess the pragmatist in me or whatever might say that the real reason to upgrade to 380 is because your code will run faster and there's a whole bunch of bug fixes. But really, it's all these cool, fun features. So first off, assignment expressions. That's the new Walrus operator that you've probably heard about. It's called the Walrus. If you haven't heard about it, it's called the Walrus operator because it's colon equals sign. And if you think of like emojis or emoticons where colon was a smiley face. This kind of looks like two eyes and Wallace tusks. So, yeah, there's the Wallace operator. What is it? So there's a whole bunch of different reasons why you would put this in here, but the idea is if you normally have a couple of lines where you have something with an assignment and you want to do it in an expression at the same time, like in an if clause or a while clause or something like that, it's sometimes annoying that you have to break these up. Like in old C Code, you used to be able to just say assign to a pointer in the if statement or in a while loop, and when the pointer finally hit the null Terminator, it would jump out of the while loop. Well, you can kind of do that in Python. Now, we don't have null Terminators, but we do have like nuns and stuff. So often you'll grab something out of a database or grab something out of a data structure, and if it's none or zero or empty, you don't want to do anything. But if it has a value, you want to do something. That's exactly the case where assignment expressions are going to be super handy, and I think I'm just going to start using these and see if most of my colleagues catch on and go, what the heck are you doing here, man? Hopefully they're listening to this podcast, too.

00:07:31 Thank you to PyCharm for sponsoring this episode. If you're going to try out Python three eight, you should consider using PyCharm to try it out. Pycharm tool tips and built in syntax checking is all ready for 38, helping you with the position only parameters, assignment expressions, and the cool equal option at the end of the F strings the whole bit, as well as saving you time with other handy features. I recently learned about Refactor in Line, a feature that replaces all the calls to a function with the body of the function. Seems weird, but for really small function, it sometimes actually makes the code way more readable, and if it's not readable, you can just undo it. There's a lot of refactor goodies, actually, that make incredible time savers. So head to testandcode.com PyCharm before October 29 to try PyCharm for four months. Why pro?

00:08:21 Well, you never know what features you absolutely can't live without. I didn't know I needed PyCharm as a remote Postgres Admin interface or SQL Schema Visualization, and now I never want to go without it. Give it a try yourself at testandcode.com, piechar.

00:08:39 Next feature I want to talk about is positional only parameters. Now this is kind of a big thing for a lot of people.

00:08:47 We have like the star for keyword to separate your arguments from keyword only. And now we have a function definition. You can have a slash in the middle of your variable names and it will say that it will divide the positional only from the rest of the stuff. Yeah, I think there's a lot of people excited about using this. I think it will help clear things up for when you're accessing C libraries, because position mapping is definitely important when you're linking with C functions. Outside of that, I know there's probably some cool uses. I'm probably not going to use it much, but it's here. Positional only parameters with a slash. The third item I wanted to talk about was F strings support the equal sign at the end for self documenting expressions and debugging. Well, actually the explanation is longer than just doing it. The gist is if you use an F string with an expression in it and put an equal sign at the end by the closing squiggly bracket, what you get is the string will be replaced with the expression not evaluated with an equal sign, and then the expression evaluated on the right. So all those times when you're debugging with print statements or logging where you say print value equals then the curly bracket value. So you've done this all the time. I do it all the time too. Yes. I still debug with print statements sometimes. It's a lot easier now with this little expression thing. This is totally cool. I love it. Now in this document it has other language changes. So I guess all the rest of these are lumped into not as important to as many people, I guess are not as controversial. I'm not sure, but there's a long list. I pulled out a few that I thought were neat. The Bull, Int and fraction type now have an as integer ratio method. Why do I care about that? Yeah, it's just neat.

00:10:52 So you can say numerator and denominator equals X as integer ratio.

00:10:58 I don't know. It's kind of cool. I'm surprised we didn't have that already. This next one is added support of named escapes.

00:11:07 It's kind of like the F string type thing, but in regular expressions. And it's something like if you have the Copyright and the Copyright symbol and you want to be able to search for that in regular expression, all these symbol things. What it is is you can do a slash backslash, capital in, and then in brackets like you would the F strings, curly brackets, the name of the Unicode character. And you can just use Unicode character names then within regular expressions and it makes your regular expressions that have Unicode characters easier to read. That's actually pretty cool. I didn't know that that was going in until I was just looking through this list today. Next, dictionaries and Dick's views are now Iterable in reversed insertion order using reversed. That's cool. I don't think I've ever wanted to do that. But it's neat. So reversed insertion order neat. Next up, you know how when you return a return or yield a value from a function in closing parentheses around them, you don't have to do that anymore. Basically, you could just return and you can have a list of values and it returns a tuple. You don't have to put them in the make a tuple before you return it. That's cool. Oh, this is great. The next one is when a comma is missing in a list of let's say you've got a list of tuples and you forgot to put the comma before between the tuples.

00:12:33 It isn't valid syntax, but like, for instance, this happens to me a lot when I'm doing parameterized testing. I've got parameterized testing. It's full of lists of tuples. And if you forget one of the commas, it's a syntax error. And it always has been a syntax. I think it has always been. I guess it was a type error sometimes.

00:12:52 Now the compiler just plays a syntax warning with a helpful suggestion, so you'll be able to figure that out better. So, yeah, it's a mistake. I always do.

00:13:03 Apparently, there's a new module, and this is kind of neat. It's called import Lib metadata. So this module provides support for reading metadata from third party packages. For example, it can extract an installed packages, version number, list of entry points, and more. So you can say something like from import Lib metadata, import say version or requires or files requires. That's neat. And you can look at the version number of something you imported. That's really cool. We'll look at what it requires. I wonder what that is. I'll have to try that. That's neat. The next section is Improved Modules. This is kind of cool.

00:13:48 I wanted to play with Async stuff, and when I play with Python, sometimes I do it on the command line or not the command line. Yeah, I do that, too. But sometimes in the reple, because Python has this cool rep built in. Now Python am async. Io will launch a native Async rep. So you can play with Async code right in the rep. How cool is that?

00:14:12 I got to admit, Nerdy kind of person. I do use the LRU cache occasionally, so if you don't know what LRU cache is. Yeah, skip the section. But funk two is just a minor change.

00:14:28 You used to have to decorate a function with the LRU cache with a parenthesis. It looked like a function call. And if you forgot that, it didn't work right. But now you don't have to do you can leave off the parentheses, you can use it with or without parentheses, and it still works. That's cool. A couple of new math functions. So in the math package, there's Math disk for computing Euclidean distance between two points. So if you give it like two X and Y two poles and get the distance between those two, that's kind of neat. This is neat. There's a math prod, and what that does is it's kind of like sum. So if you take the sum of a whole bunch of numbers, it just adds them up. But prod will multiply them all up. And it also will take a default start value. The default is one, but you can say take these lists and multiply them all together and have a start value for multiplying. That's kind of cool. So it's like some but multiply. There's a couple of other math functions, but I'll skip those. Os path and Path both have similar changes that there were methods like exists and is file is Mount, things like that. Is link.

00:15:40 If you gave them gibberish, like if you gave them something that your operating system really couldn't use as a realistic path, it would throw an exception. Now it just returns false, which is cool, because if you're going through a list of stuff in a file or something and you want to know if all of them are real directories, if it's gibberish, then false is the right answer. It's not a link, it's not a directory, it's chippers. So yeah, cool. So returns false instead of throwing exceptions. All right, we've covered Python type stuff, type hints and everything a lot on Python bites. But in Python 38 there's a few added features for typing.

00:16:25 Some of them are kind of neat. There's a type dictator, which is cool. It's dictionary type with per key types. I think this is kind of neat.

00:16:35 One of the things I wanted to highlight that I wasn't aware of right away is literal types.

00:16:41 So let's say you've got a function that takes an integer. The type hinting will tell you to make sure if you run it through my pie or something, and we'll make sure that the functions only call with integers. But with this literal thing, you can say not just integers, but these are only these integers. So you can only have these literal values. You can only pass in four or something like that. And for a lot of things, especially like string things like think all of the flags for all the read and write flags for files like R plus or W plus, there's only a handful of those things that are valid. So having the type hinting system type checking tell you whether or not you're getting this right is kind of neat. Final is available. So like, let's say you define pie, you don't want to define it twice. You can final is available through the type hinting meet.

00:17:36 Of course, everybody on this podcast knows that I'm Pipest fan, but I also am very respectful for Unit Test with all of the async stuff. I didn't see this coming. I don't know why I didn't see it coming. But of course we might need to mock async things. And in Python 38, Unit Test adds async mock, which is an asynchronous version of mock. That's nice. Also, there are set up module and set up class functions. Those have been there, but now there are extra add module cleanup and add class cleanup functions. So you can register register cleanup functions for those fixtures. Nice. Several mock assert functions now also print a list of actual calls upon failure. That's cool.

00:18:25 Lastly, for the standard library changes that I wanted to cover, virtual environments, there's one little change that when you create a virtual environment on a Windows machine you can get all these Activate scripts. It's cool. It gives you the bash one. Also because I do use Get Pash on Windows so I like the activate that I can source in for virtual environments. But if you're using it in a normal man prompt, there's another one for that. But the change is there wasn't previously support for PowerShell and now there is there's an activate.

00:19:01 Ps one? Is it PS One or PSL? I don't know. But anyway, there's a PowerShell version that is now in virtual environments on Windows. Cool. Last thing I wanted to cover was this cool benchmark. At the end there's a thing called a section that says demos and tools and there was a benchmark script for timing various ways to access variables. It's under Toolscriptsvaraccessbenchmark PY so when you install Python there's an extra benchmark thing that you can run. It kind of just prints out all the stuff.

00:19:36 It tries all of these different ways to access variables and tells you how long it takes. I don't know why I wanted to highlight this, I just thought it was neat. That's actually all the features I wanted to cover. I am excited about some of the features, some of them are just interesting.

00:19:51 If there's some new thing that you really love and 38 that I didn't cover, I'd love to hear what it is.

00:19:57 So reach out to me. I'm at Brian Hawkins and Twitter or you can reach me through the test and code test and code at Test podcast on Twitter also. Or you can reach me at the what you call it, the contact page on Testing code.com.

00:20:17 Thanks to PyCharm for sponsoring this episode now through October 29, you can get four months of pycharm at testandcode.com PyCharm. That link is also in the show notes at testandcode.com 91 along with the link to the full 3.8 what's new document? Thank you to Patreon supporters as well for helping to support the show. Join them@testandcode.com. Support that's all for now. Now go out and try some Python 3.8 and maybe go test something.